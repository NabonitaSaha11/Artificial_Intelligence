# -*- coding: utf-8 -*-
"""22301645_Nabonita Saha_03.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YN30YFClsvQcPg9k4TU7VSgif4MFkx67
"""

#TASK 01

import random
import math


def strength(x):
    return math.log2(x + 1) + (x / 10)



# Utility function jeta leaf nodes er jonno use kori
def utility_function(maxV, minV):
    i = random.choice([0, 1])
    rand_val = random.randint(1, 10)
    utility= strength(maxV) - strength(minV) + ((-1) ** i) * (rand_val/10)
    return utility



def minimax(depth, isMaximizing, alpha, beta, maxV, minV):
    if depth == 5:
        return utility_function(maxV, minV) # leaf node er jonno utility value return korbe


    if isMaximizing==False:
        minval = float('inf')
        for i in range(2):
            eval = minimax(depth+1, True, alpha, beta, maxV, minV)
            beta = min(beta, eval)
            minval = min(minval, eval)
            if alpha >= beta:
                break
        return minval


    else:   # Maximizing player er turn
        maxval = -float('inf')
        for j in range(2):
            eval = minimax(depth + 1, False, alpha, beta, maxV, minV)
            alpha = max(alpha, eval)
            maxval = max(maxval, eval)
            if alpha >= beta:
                break
        return maxval




# 4 ta game er jonno kaaj kore
def chess_games(starting_player, basestrength_Magnus, basestrength_Fabiano):
    results = []
    players = ["Magnus Carlsen", "Fabiano Caruana"]



    for game in range(4):

        if (starting_player == 0 and game % 2 == 0) or (starting_player == 1 and game % 2 == 1 ):
            magnus_is_max = True   # Magnus maximizing player
        else:
            magnus_is_max = False


        if magnus_is_max==True :
            maxV = basestrength_Magnus
            minV = basestrength_Fabiano
        else:
            maxV = basestrength_Fabiano
            minV = basestrength_Magnus


        rootnode_value = minimax(0, True, -float('inf'), float('inf'), maxV, minV)



        if rootnode_value < 0:
            if game % 2 == 0:
                winner = f"{players[1 - starting_player]} (Min)"
            else:
                winner = f"{players[starting_player]} (Min)"
        elif rootnode_value > 0:

            if game % 2 == 0:
                winner = f"{players[starting_player]} (Max)"
            else:
                winner = f"{players[1 - starting_player]} (Max)"
        else:
            winner = "Draw"


        results.append((game + 1, winner, rootnode_value)) #ekhane game outcome store thaktese

        print(f"Game {game + 1} Winner: {winner} (Utility value: {round(rootnode_value, 2)})")




    # win count
    wins_Magnus= 0
    wins_Fabiano= 0
    draws= 0
    for game_number, winner, utility_value in results:
        if "Magnus Carlsen" in winner:
            wins_Magnus += 1
        elif "Fabiano Caruana" in winner:
            wins_Fabiano += 1
        else:
            draws += 1


    print("\nOverall Results:")
    print(f"Magnus Carlsen Wins: {wins_Magnus}")
    print(f"Fabiano Caruana Wins: {wins_Fabiano}")
    print(f"Draws: {draws}")

    if wins_Magnus > wins_Fabiano:
        print("Overall Winner: Magnus Carlsen")
    elif wins_Fabiano > wins_Magnus:
        print("Overall Winner: Fabiano Caruana")
    else:
        print("Overall Winner: Draw")




# Taking my user inputsss
starting_player = int(input("Enter starting player for game 1 (0 for Carlsen, 1 for Caruana): "))
basestrength_Magnus = float(input("Enter base strength for Carlsen: "))
basestrength_Fabiano = float(input("Enter base strength for Caruana: "))

chess_games(starting_player, basestrength_Magnus , basestrength_Fabiano)

# TASK 02

import random
import math

def strength(x):
    return math.log2(x + 1) + (x / 10)


def utility_function(maxV, minV, precomputed_random, depth):
    if depth == 5:

        rand_val = random.randint(1, 10)
        i = random.choice([0, 1])
        utility = strength(maxV) - strength(minV) + ((-1) ** i) * (rand_val / 10)
    else:
        # leaf node bade onno node e randomness nai utility te
        utility = strength(maxV) - strength(minV)
    return utility



def precompute_random_values():
    precomputed_random = {}
    for depth in range(5):
        rand_val = random.randint(1, 10)
        i = random.choice([0, 1])
        precomputed_random[depth] = (rand_val, i)
    return precomputed_random





def minimax(depth, isMaximizing, alpha, beta, maxV, minV, precomputed_random):
    if depth == 5:
        return utility_function(maxV, minV, precomputed_random, depth)

    if isMaximizing== False :
        minval = float('inf')
        for j in range(2):
            eval = minimax(depth + 1, True, alpha, beta, maxV, minV, precomputed_random)
            minval = min(minval, eval)
            beta = min(beta, eval)
            if alpha >= beta:
                break  #unnecessary branch explore hobena
        return minval
    else:
        maxval = -float('inf')
        for i in range(2):
            eval = minimax(depth + 1, False, alpha, beta, maxV, minV, precomputed_random)
            maxval = max(maxval, eval)
            alpha = max(alpha, eval)
            if alpha >= beta:
                break
        return maxval





def minimax_dark_magic(depth, isMaximizing, alpha, beta, maxV, minV, precomputed_random):
    if depth == 5:
        return utility_function(maxV, minV, precomputed_random, depth)

    if isMaximizing==True :
        maxval = -float('inf')
        for i in range(2):
            eval = minimax_dark_magic(depth + 1, False, alpha, beta, maxV, minV, precomputed_random)
            alpha = max(alpha, eval)
            maxval = max(maxval, eval)

            if alpha >= beta:
                break
        return maxval
                                        # ekhane minimizing ar maximizing er kaaj duitai maximizing er moto hocche ( black magic er belay)
    else:
        maxval = -float('inf')
        for j in range(2):
            eval = minimax_dark_magic(depth + 1, True, alpha, beta, maxV, minV, precomputed_random)
            alpha = max(alpha, eval)
            maxval = max(maxval, eval)

            if alpha >= beta:
                break
        return maxval




def play_chess(starting_player, mind_cost, basestrength_L, basestrength_Light):
    players = ["Light", "L"]
    precomputed_random = precompute_random_values()

    if starting_player == 0:
        maxV = basestrength_Light
    else:
        maxV = basestrength_L

    if starting_player == 0:
        minV = basestrength_L
    else:
        minV = basestrength_Light




    # ekhane duita minimax er kaaj e joma rakha hocche
    root_value_with_magic = minimax_dark_magic(0, True, -float('inf'), float('inf'), maxV, minV, precomputed_random)
    root_value_with_magic_after_cost = root_value_with_magic - mind_cost
    root_value_no_magic = minimax(0, True, -float('inf'), float('inf'), maxV, minV, precomputed_random)

    print(f"Minimax value without Mind Control: {round(root_value_no_magic, 2)}")
    print(f"Minimax value with Mind Control: {round(root_value_with_magic, 2)}")
    print(f"Minimax value with Mind Control after incurring the cost: {round(root_value_with_magic_after_cost, 2)}")


    if root_value_with_magic_after_cost < root_value_no_magic:
        print(f"{players[starting_player]} should not use Mind Control.")
    else:
        print(f"{players[starting_player]} should use Mind Control.")




# input niye code ekhane shuru hocche

starting_player = int(input("Enter who goes first (0 for Light, 1 for L): "))
mind_cost = float(input("Enter the cost of using Mind Control: "))
basestrength_Light = float(input("Enter base strength for Light: "))
basestrength_L = float(input("Enter base strength for L: "))

play_chess(starting_player, mind_cost, basestrength_L, basestrength_Light)