# -*- coding: utf-8 -*-
"""22301645_Nabonita Saha_02.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kOK6xY1eyWZhDyGguBmiWaneBfGXmVw_
"""

#task 01
import random

primary_population=[]


def generate_chromosome(): #here we randomly generate the parameters to form the chromosome

    stop_loss = random.randint(1, 99)
    take_profit = random.randint(1, 99)
    trade_size = random.randint(1, 99)
    return encode_chromosome(stop_loss, take_profit, trade_size)


def encode_chromosome(stop_loss, take_profit, trade_size):

    stop_loss_str = str(stop_loss)
    if len(stop_loss_str) == 1:
        stop_loss_str = "0" + stop_loss_str

    take_profit_str = str(take_profit)
    if len(take_profit_str) == 1:
        take_profit_str = "0" + take_profit_str

    trade_size_str = str(trade_size)
    if len(trade_size_str) == 1:
        trade_size_str = "0" + trade_size_str

    #here I kept the whole chromosome in the form of a string
    encoded_chromosome = stop_loss_str + take_profit_str + trade_size_str

    return encoded_chromosome



def decode_chromosome(chromosome):
    return {"stop_loss": int(chromosome[:2]),"take_profit": int(chromosome[2:4]),"trade_size": int(chromosome[4:]) }







def generate_initial_population(size):

    initial_population = []
    for val in range(size):
        chromosome = generate_chromosome()
        initial_population.append(chromosome)

    primary_population.append(initial_population)


    return initial_population






def simulate_trading(chromosome, historical_prices, initial_capital=1000):
    # we do this simulation based on 10 days outcome
    values= decode_chromosome(chromosome)
    capital = initial_capital

    for price_change in historical_prices:
        trade_size = capital * (values["trade_size"] / 100)

        if price_change <= -values["stop_loss"]: #for SL hittt :(
            capital =capital - trade_size * (values["stop_loss"] / 100)
        elif price_change >= values["take_profit"]:  # for TP hit :)
            capital =capital + trade_size * (values["take_profit"] / 100)
        else:
            capital =capital + trade_size * (price_change / 100)

    fitness= capital - initial_capital
    return fitness





def select_parents(population):
    parent1, parent2 = random.sample(population, 2)
    return parent1, parent2



def crossover(parent1, parent2):

    point = random.randint(1, 5)
    child1 = parent1[:point] + parent2[point:]
    child2 = parent2[:point] + parent1[point:]
    return child1, child2





def mutate(chromosome, mutation_rate=0.05):
    if random.random() > mutation_rate:
        index = random.randint(0, 5)
        new_digit = str(random.randint(0, 9))
        chromosome = chromosome[:index] + new_digit + chromosome[index+1:]
    return chromosome





def genetic_algorithm(generations, population_size, historical_prices):

    population = generate_initial_population(population_size)
    best_chromosome, best_profit = None, float('-inf')

    for val in range(generations): #10 generation er jonno protibar 4ta kore chromosome er moddhe theke random 2 ta niye crossover + mutate kore, fitness check er through te best fit khuja hoy
        parent1, parent2 = select_parents(population)
        child1, child2 = crossover(parent1, parent2)
        child1, child2 = mutate(child1), mutate(child2)

        population = [parent1, parent2, child1, child2]


        for chrom in population:
            profit = simulate_trading(chrom, historical_prices) #works on fitness ekhane
            if profit > best_profit:
                best_profit = profit
                best_chromosome = chrom

    return best_chromosome, best_profit








# Starting my code from here :

historical_prices = [-1.2, 3.4, -0.8, 2.1, -2.5, 1.7, -0.3, 5.8, -1.1, 3.5]
best_strategy, final_profit = genetic_algorithm(10, 4, historical_prices)


print("Best Strategy :", decode_chromosome(best_strategy))
print("Final Profit:", final_profit)

#task 02

def two_point_crossover(parent1, parent2):



    point1 = random.randint(1, len(parent1) - 2)
    point2 = random.randint(point1 + 1, len(parent1) - 1)

    child1 = parent1[:point1] + parent2[point1:point2] + parent1[point2:] #basically ekhane xyx form follow hocche
    child2 = parent2[:point1] + parent1[point1:point2] + parent2[point2:]  #yxy form follow hocche

    return child1, child2, point1, point2





population = primary_population[0] #I have put the initially generated population here

parent1, parent2 = select_parents(population)
child1, child2, crosspoint1, crosspoint2 = two_point_crossover(parent1, parent2)
print("Parent 1:", parent1)
print("Parent 2:", parent2)
print(f"Crossover Points: {crosspoint1}, {crosspoint2}")
print("Offspring 1:", child1)
print("Offspring 2:", child2)